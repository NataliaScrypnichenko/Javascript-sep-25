let users = [
    {name: 'vasya', age: 31, status: false},
    {name: 'petya', age: 30, status: true},
    {name: 'kolya', age: 29, status: true},
    {name: 'olya', age: 28, status: false},
    {name: 'max', age: 30, status: true},
    {name: 'anya', age: 31, status: false},
    {name: 'oleg', age: 28, status: false},
    {name: 'andrey', age: 29, status: true},
    {name: 'masha', age: 30, status: true},
    {name: 'olya', age: 31, status: false},
    {name: 'max', age: 31, status: true}
];
// //силочних типів даних є важливий нюанс і це буде важливо
//
// //колбек являється функцією бо круглі дужки описані у,цієї ф-ї є аргументи value,index,array
// //в функції forEach() так назвали аргумент- це аргумент====
// // callbackfn:(value{name:string,age:number,status:boolean[]},index:number, array:{name:string,age:number,status:boolean}) => void
// //index-по факту це індекс об'єкта справжнього ,число,
// // array-масивом наших об'єктів,то б то наявний масив users[]
// // value -являється(об'єктом в якому є name,age,status) моделлю данних така як зберігається в  нашому масиві кожний об'єкт
// //Сама по собі функція нічого не повертає
// // коли бачимо (void) то це свідчить про те що наша функція після свого від працюваня нічого не повертає(якщо вона повертає тру або фолз, або масив об'єктів то б вона показувала б )
// // обовязково пепреглядати підсказки які показує інтелендж
//
// // все наступне буде схоже і в середину ми передаємо функцію- яка приймає три об'єкта(function(value,index, array))ми тут тільки зробили функцію(тому що
// // в джаваскрипті фунцкція об'єктом то її як аргументом може використовувати під капотом  якась інша функція )ФУНКЦІЮ МОЖНА ПЕРЕДАВАТИ ЯК АРГУМЕНТЯК .
// // value = user;
// // ЦЕ ЗРОБИТИ САМРСТІЙНО?????,буде в кінці урока.
// users.forEach(function(value) {
//     console.log(value);// будемо застосовувати
//   //  console.log(index);=будемо застосовувати
//     //console.log(array);- тут ми можемо і не вказувати array
// })
// // тобто тут описано як себе поводить forEach() і він бере кожний елемень і ітерує його
// // так не принято описувати в колбеках береться друге
// // тут ми прописуємо стрілочну функцію і вказуємо що вона робить,якщо один аргумент то ми його не беремо в дужки, а більше так
// //назва аргумента довільна
// // user.forEach((value) =>console.log(value));
//
// // філь трація стара але її можна використовувати
// // let a=[];
// // for (let user of users){
// //     if () {
// //         a.push(user);
// //     }
// // }
// //вона приймає колбеки такіж..ця функція повина повертати булеве значення
// // let filteredUsers =  users.filter(function (value)  {
// //     return value.age >30;
// // } );
// // console.log(filteredUsers);
// // ///можна записати ось так
// // let filteredUsers1= users.filter(value => value.age >30 );
// // console.log(filteredUsers1);// це новий об'єкт повертається
// // console.log(users);//початковий не змінний
//
// //map()= приймає такий же колбект, але після опрацювання повертає новий об'єкт
// // Тобто будемо мапувати(то б то щось додати в масив) якийсь масив до якогось нового масиву
// // зараз потрібно змінити васю додати до нього якийсь індитифікатор
// let mapedUsers=  users.map(function(value, index){
//  let newUser = {
//      name: value.name,
//      age: value.age,
//      status: value.status,
//      id: index + 1,//index-характиризує під яким індексом знаходиться наш ітеруємий об'єкт, який знаходиться в нашом масиві
//  };// тут ми створили об'єкт
//     return newUser;// тут повернули його і він попаде в новий масив
// })
// console.log(mapedUsers);

// //map()-дає можливість на основі старого масива зробити новий
// //можна зробити по іншому тобто зразу повертати новий об'єкт
// let mapedUsers1=  users.map(function(value, index){
//     return  {
//         name: value.name,
//         age: value.age,
//         status: value.status,
//         id: index + 1,
//     };
// });
// console.log(mapedUsers1);
//
// // пишемо за допомогою стрілочною ф-ї
// users.filter((value, index) => {
//     return {name: value.name, age: value.age, status: value.status, id: index + 1,}
// });
//
// // повеликому рахунку, він являє собі фільтер, але знаходить тільки перше ходження певного елементе по певній умові
// //то б то якщо в масиві два макса то він знайде тільки першого макса і далі вона не шукає
// let elementFind=  users.find(value => value.name === 'max');// колбек функція зобовязана повертати булеве значення
// console.log(elementFind);
//
// //ці функції застосовуються в комплексі зазвичай
// //every-перепровіряє вкожного елемента на явність якоїсь умови
// let ever= users.every((value => value.status))//провіряє статус true якщо хоч
// // один має статус false, то дасть відповідь false
// console.log(ever);
//
// console.log(users.some(value => value.status));//перевіряє чи має якийсь елемент тру,
// // і якщо в сридині є хоч один елемент з статусом тру то покаже тру

// //цей колбек чи функція приймає обов'язково 2 аргументи
// //sort()-можна щось сортувати, приймає він завжди тільки два аргумета(а- це в нашому випадку буде name: 'vasya',
// // а b-name: 'petya',==це г+на першій ітерації)- тобто ця функція завжди бере  між собою 2 об'єкта і так нище а=name: 'petya',а b-name:'kolya' і т.д
// //ми тут їх порівнюємо і якимось чином повині повернути з функції интове значення(числове)тобто порівнюємо,<, >,= ///на основі умови може поміняти їх оба залишити їх так же
// // let sort= users.sort((u1, u2) =>{
// //     //console.log(a, b);Показує що під капотом це для мене, то б то вони сусіди
// //     return u1.age -u2.age;//повернути різницю-і сортує зразу
// // } );
// // console.log(sort);//зараз тут зростання від меншого до більшого
// //якщо хочемо отримати в зворотньому напрямі то потрібно return u2.age -u1.age // так покаже від більшого до меншого
//
// //сортувати по імені
// console.log(users.sort((a, b) => {
//     if (a.name > b.name) {//більше//зробити в зворотньому напрямі міняємо на <
//         return 1;
//     };
//     if (a.name < b.name) {// менше//зробити в зворотньому напрямі міняємо на >
//         return -1;
//     };
//     if (a.name === b.name) {
//         return 0;
//     }
// }));

//зменшування чогось/він може приймати колбек чи масив і щось повертати 29.44
//Тобто він зручний для компонуваня об'єктів
// users.reduce((previousValue, currentValue) => {
//     console.log(currentValue, currentValue );
// }, [])
 let reduce = users.reduce((accumulator,user) => {
  if (user.status){
      accumulator.statT.push(user);
  }else {
      accumulator.statF.push(user);
  }
 return accumulator;//робиться він для того щоб це об'єкт замінили на новий або
}, {statT:[], statF:[]})

console.log(reduce);
